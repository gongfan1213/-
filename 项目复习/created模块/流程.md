### 业务逻辑详细说明与流程图

#### **1. 项目列表初始化加载**
**流程描述**：
1. **组件挂载**：`MainUiLeftProject` 组件加载时，检查 `DataCache` 中是否有缓存的项目列表数据。
2. **缓存命中**：若缓存存在且有效，直接使用缓存数据渲染列表。
3. **缓存未命中**：若缓存不存在或无效，发送分页请求到服务端获取第一页数据。
4. **数据存储**：将获取的数据存入 `DataCache` 并更新组件状态，渲染项目列表。

**流程图**：
```mermaid
graph TD
    A[MainUiLeftProject组件挂载] --> B{检查DataCache是否有缓存?}
    B -->|有缓存| C[从DataCache读取数据]
    B -->|无缓存| D[发送分页请求获取第一页数据]
    D --> E[数据存入DataCache]
    C --> F[更新组件状态,渲染列表]
    E --> F
```

---

#### **2. 滚动分页加载更多数据**
**流程描述**：
1. **滚动触底**：用户滚动到列表底部，`ScrollMoreView2d` 组件通过 `useInView` 检测到触底事件。
2. **触发加载**：调用 `onLoadMore` 回调函数，递增 `pageIndex`。
3. **发送请求**：向服务端发送下一页数据请求。
4. **数据合并**：将新数据与现有列表合并，更新 `DataCache` 和组件状态。
5. **更新UI**：渲染新增项目，保持滚动连续性。

**流程图**：
```mermaid
graph TD
    A[用户滚动到底部] --> B{ScrollMoreView2d检测到触底}
    B -->|是| C[触发onLoadMore回调]
    C --> D[递增pageIndex]
    D --> E[发送分页请求获取下一页数据]
    E --> F{请求成功?}
    F -->|成功| G[合并新旧数据,更新DataCache]
    F -->|失败| H[显示错误提示]
    G --> I[更新组件状态,渲染新项目]
    H --> I
```

---

#### **3. 项目删除操作**
**流程描述**：
1. **用户操作**：用户选中一个或多个项目，点击删除按钮。
2. **弹窗确认**：`MainUiLeftFooterBar` 显示确认弹窗，用户确认删除。
3. **发送请求**：调用 `deleteProjectList` 发送删除请求到服务端。
4. **本地更新**：
   - **过滤列表**：从本地 `projectList` 中移除已删除项。
   - **更新缓存**：同步更新 `DataCache` 中的缓存数据。
5. **状态重置**：清空选中项 `selectedItems`，关闭弹窗和编辑模式。
6. **边界处理**：若删除后列表为空且还有数据，重置页码并重新加载第一页。

**流程图**：
```mermaid
graph TD
    A[用户选择删除项目] --> B{是否包含当前编辑项目?}
    B -->|是| C[弹出错误提示]
    B -->|否| D[弹出确认弹窗]
    D --> E{用户确认删除?}
    E -->|是| F[发送删除请求]
    E -->|否| G[关闭弹窗]
    F --> H{请求成功?}
    H -->|成功| I[过滤本地列表,更新DataCache]
    H -->|失败| J[显示错误提示]
    I --> K[清空选中项,关闭弹窗]
    K --> L{列表是否为空且有更多数据?}
    L -->|是| M[重置pageIndex=1,重新加载]
    L -->|否| N[结束]
```

---

#### **4. 缓存管理策略**
**关键逻辑**：
- **缓存写入**：每次分页加载或删除操作后，更新 `DataCache` 中的 `pageData`、`pageSize` 和 `hasMore`。
- **缓存失效**：
  - **显式失效**：删除操作后直接更新缓存列表。
  - **隐式失效**：未实现自动过期机制，依赖用户手动刷新或重新加载。
- **数据一致性**：本地缓存可能滞后于服务端，需在关键操作（如删除）后强制刷新。

**流程图**：
```mermaid
graph TD
    A[数据变更操作] --> B[更新本地状态]
    B --> C[更新DataCache]
    C --> D{是否需要强制刷新?}
    D -->|是| E[清除缓存,重新加载第一页]
    D -->|否| F[保持缓存状态]
```

---

#### **5. 完整业务流程图**
```mermaid
graph TD
    A[用户打开项目列表] --> B[初始化加载检查缓存]
    B --> C{缓存有效?}
    C -->|是| D[渲染缓存数据]
    C -->|否| E[加载第一页数据]
    E --> F[更新缓存并渲染]
    F --> G[用户滚动到底部]
    G --> H[加载下一页数据]
    H --> I[合并数据并更新缓存]
    I --> G
    G --> J[用户选择项目删除]
    J --> K[检查是否包含当前编辑项目]
    K -->|是| L[提示错误]
    K -->|否| M[弹窗确认删除]
    M --> N{用户确认?}
    N -->|是| O[发送删除请求]
    N -->|否| P[取消操作]
    O --> Q{删除成功?}
    Q -->|是| R[更新本地列表和缓存]
    Q -->|否| S[提示删除失败]
    R --> T{列表为空且hasMore=true?}
    T -->|是| U[重置页码,重新加载]
    T -->|否| V[结束]
```

---

### **关键问题解答**
1. **DataCache与cache.ts的区别**：
   - **DataCache**：单例类，用于全局缓存分页数据（如项目列表、上传素材），提供 `setCacheItem` 和 `getCacheItem` 方法。
   - **cache.ts**：React组件，扩展了事件监听功能（如 `EventUpdateMaterial`），用于特定场景的缓存更新。

2. **ProjectManager与React组件交互**：
   - **事件驱动**：通过 `CanvasEventEmitter` 触发事件（如 `EventProjectChangeState`），组件监听事件更新状态。
   - **方法调用**：组件直接调用 `ProjectManager.getInstance()` 的方法（如 `changeProject`）。

3. **删除后缓存一致性**：
   - **本地过滤**：删除后立即从 `projectList` 和 `DataCache` 中移除对应项。
   - **强制刷新**：若删除导致列表为空且 `hasMore` 为 `true`，重置页码重新加载，确保缓存与服务端同步。

4. **分页实现细节**：
   - **页码管理**：`pageIndex.current` 跟踪当前页码，每次滚动加载递增。
   - **滚动检测**：`ScrollMoreView2d` 使用 `useInView` 监听底部元素，触发 `onLoadMore` 回调。
