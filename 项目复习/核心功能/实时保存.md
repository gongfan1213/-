

**核心目标：** 对画布图层进行实时保存，优化保存性能，保证数据同步成功率。

**关键策略：**

1.  **图片特殊处理：** 画布中的图片单独上传，获得上传后的 key。
2.  **数据替换：** 将画布内容中的 base64 数据替换为图片的 key。
3.  **降低消耗:** 减少保存的流量消耗和时间消耗。

**保存流程 (结合流程图和文字描述):**

1.  **触发保存:**
    *   新建项目
    *   切换项目
    *   触发保存画布

2.  **判断是否需要保存:**
      *  判断模版是否有修改.

3.  **实时保存内容:**
    *   画布 JSON
    *   缩略图

4.  **元素来源与上传：**
    *   **模版层面的图片:** (上传设置类型1018)
        *   直接上传
    *   **官方/个人元素里面的图片** (status导入)
        *   直接上传
    *   **用户本地导入:**
      *   上传图片,上传类型为:
          1.  项目图片
          2.  AI生图导入
          3.  base64
          4.  本地缓存上传过的图片（updateToken获取，本地导入和模版层面图片，通过元素id区分）。

5.  **执行队列任务:**
    *    **判断是否上传成功:**
      * true: 上传图片
      * false:上传json

6.  **上传图片处理:**
    *   上传缩略图
    *   上传画布图
    *   上传原图

7.  **上传json：**
    *   提供 base64, 然后上传 json

8. **上传维度定位:**
   *  上传是否成功:
   *  上传类型:
       1.  模版来源也继续这样，把鼠标移到base64上传

9.  **队列任务成功/失败**
    *   成功（true）：上传管理 key，不做处理
    *   失败 (false): 执行队列任务

**接口设计 (上传与下载):**

*   **上传接口:**
    *   `project_path`: 项目工程文件上传链接
    *   `thumb_path`: 项目缩略图上传链接
    *   `output_path`: 项目设计图片上传链接
    *   `scene_path`: 项目场景图上传链接
    *   `print_path`: 项目打印文件上传链接
    *   `share_path`: 项目分享文件上传链接
    *   `publish_path`: 项目发布文件上传链接

*   **下载接口:**
    *   `download_urls`: (类型: `ProjectDownloadUrls`，具体结构未知)
    *   `project_path`: 项目工程文件下载链接
    *   `thumb_path`: 项目缩略图下载链接
    *   `output_path`: 项目设计图片下载链接
    *   `scene_path`: 项目场景图下载链接
    *   `print_path`: 项目打印文件下载链接
    *   `share_path`: 项目分享文件下载链接
    *   `publish_path`: 项目发布文件下载链接
    *   下载获取

**补充说明和注意事项:**
*   **图片类型:** 文档中特别提到了AI生图。
*   **本地缓存:** 利用本地缓存已经上传过的图片,使用updateToken获取图片
*    **同步成功率:** 目标是保存内容同步成功率 > 99.9%。
*   **每周添加、删除图片的调用:** 需要调用项目接口。
*   **图片添加入口：**
    1.  模版里面的图片（上传设置类型1018）
    2.  官方/个人元素里面的图片(status导入)
    3.  用户本地导入 (上传类型设置1018)
    4.  AI生图导入
    5.  判断是否重复上传:
        * base64
        * 本地缓存上传过的图片（updateToken获取,本地导入和模版层面图片，通过元素ID区分）


**总结:**

这个保存逻辑的核心在于将图片和画布数据分开处理。图片单独上传，获得唯一的 key，然后用 key 替换画布 JSON 中的 base64 数据。这样做既能优化性能，又能保证数据的一致性。同时，通过队列任务和详细的接口设计，确保了上传和下载的可靠性。本地缓存和对不同图片来源的处理进一步提升了用户体验和系统效率。
