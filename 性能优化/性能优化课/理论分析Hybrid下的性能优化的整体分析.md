- 首屏时间、白屏时间、卡顿等的优化方案它们一般适用于 App 端内和端外两种场景App 端内就
是 App 内的 H5 页面端外是指 PC 站或者微信里面的 H5 等页面
- Hybrid 开发模式借助 WebView把 Native 和 H5 的各自优势进行了结合
- 缺点：加载性能问题，白屏问题，界面展示和操作的局限性无法使用系统功能等等
- 结合 H5 的加载流程介绍 Hybrid App下的性能优化整体分析然后接下来几讲会详细介绍与之相关的具体优化
- H5 是 Hybrid App 当中的一个核心，它可以通过 SDK访间App 底层系统，让前端页面获取调用传感器、存储、日历/联系人等原生能力
- 进入 App →初始化 WebView →客户端发起请求 →下载 HTML 及JS/CSS 资源→解析 JS 执行 →>JS 请求数据 → 服务端处理并返回数据 → 客户端解析 DOM 并渲染 →下载渲染图片→ 完成整体渲染
- 初始化 WebView 之前都算是 App 启动阶段从初始化 WebView 到客户端解析 Dom 并渲染属于是白屏时间，剩下的环节就是整体渲染后首屏结束
# App启动阶段的优化方案
- App启动，尤其是冷启动首次启动app的时候，并不会直接初始化WebBiew，而是在创建WebView的实例的时候，才会创建它的基础框架
- 在一次二手业务列表页测试的时候发现，首次启动WebView平均时间需要400ms，二次启动平均有220ms，webbiew启动的时候占了40%的时间
# 建议使用WebBiew全局的优化方式
- 在 App 启动时启动一个 WebView 后让其全局化或者更彻底一点，把 Webview 的实例保存在一个公共池中，当用户访问这个WebView 时，直接从公共池取来加载网页，而不是重新初始化一个新的webview
# 页面白屏阶段的优化方案
- H5 页面加载的下载 HTML及 JS/CSS 资源环节当中会有哪些情况影响性能，以及会用到哪些优化方案呢
- 前端工程师将静态资源上线到CDN以后，WebView会发起网络请求去获取的
- 如果我们能把静态资源提前下载到本地，webview获取静态资源的时候就可以直接从本地获取，这样大幅降低白屏时间
- 离线包就是将包括 HTML、JavaScript、CSs 等页面内静态资源打包到一个压缩包内
- App 预先内置该压缩包到本地，然后当用户在客户端打开 H5 页面时，直接从本地加载
# 离线包是提前下载到本地的，那么更新问题怎么解决呢
- 可以在生成离线包的同时，生成一个配置文件，让app先根据这个静态文件判断是需要更新离线包，还是直接向业务服务器进行请求

# 如果静态资源本地版本实在太老此时客户端将直接向服务器端请求资源怎么办呢?
- 优化方案就是骨架屏--我们可以给客户一个心理预期，在接口请求和渲染过程中，让他知道接下来要渐进式展示的内容和结构是
什么

# 有没有办法减少最后的渲染时间呢
- SSR Server Side rendering 服务端渲染，是指客户端发起页面的请求以后，服务端直接将组件和页面的内容渲染成dom结构，返回给客户端的
### CSR(Client side rendering)
- 目前许多人在移动端上还在使用CSR，但是其实在csr方案下，它的页面的请求和数据渲染相当繁琐冗长的
# 减少数据接口加载的时间，有什么优化方案额
- 可以通过服务端优化来降低后端接口的响应的时间
- 接口和页面并行加载的角度，去做优化加载的时间，也就是接口预加载
- 第一种，通过客户端代理数据接口请求
- 在客户端初始化 WebView 的同时，直接由native 发起网络请求，H5 页面初始化完成后直接通过 SDK 向 native 获取数据
- 第二种，根据业务场景选择预加载
- 在滚动下拉列表的页面，根据用户滚动条的位置，提前加载一页的展示数据，这样用户在滚动下拉的时候不会有停止的感觉，非常流畅
- 在一些旅行类的App上，服务器端会根据用户的操作路径，判断打开搜索结果页的概率
- 如果概率超过某一个值，就会启动搜索结果页的数据获取，这样在进入搜索结果页的时候，已经有了接口数据，大大节省了时间
- 离线包命中率的统计，因为离线包即使不命中也不影响页面的效果，所以出现问题很难发现，为此，在业务上线的日常运行当中要对命中率进行统计
- webbiew优化，全局的webbiewpoll的时候一定要注意及时销毁，不然对App资源的占用比较大
- 很多公司在越加载的基础上发展出来了预渲染，但是在实施过程当中发现对App内存占用比较大

